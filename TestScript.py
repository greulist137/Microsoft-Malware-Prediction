# -*- coding: utf-8 -*-
"""
Created on Tue Mar  5 19:09:11 2019

@author: greul
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
import torch
from torchvision import datasets, transforms, models
import torch.nn as nn
import torchvision.datasets as dsets
import torchvision.transforms as transforms
from torch.autograd import Variable
from sklearn.decomposition import PCA
import csv
from itertools import chain

from sklearn.preprocessing import Imputer
from sklearn.base import TransformerMixin

from sklearn.preprocessing import OneHotEncoder

def load_checkpoint(filepath):
    checkpoint = torch.load(filepath)
    model = checkpoint['arch']
    model.load_state_dict(checkpoint['state_dict'])
    scaler = checkpoint['scaler']
    enc = checkpoint['enc']
    return model, scaler, enc

model, scaler, enc = load_checkpoint('checkpoint.pth')
print(model)


class DataFrameImputer(TransformerMixin):

    def __init__(self):
        """Impute missing values.

        Columns of dtype object are imputed with the most frequent value 
        in column.

        Columns of other types are imputed with mean of column.

        """
    def fit(self, X, y=None):

        self.fill = pd.Series([X[c].value_counts().index[0]
            if X[c].dtype == np.dtype('O') else X[c].mean() for c in X],
            index=X.columns)

        return self

    def transform(self, X, y=None):
        return X.fillna(self.fill)
    
def newImpute(df):
    for col in df.columns:
        #print(col)
        df[col].fillna(value=df[col].value_counts(),inplace =True)
    return df


def makePredict(df):
    trainData = pd.DataFrame(df)
    machineIdent = trainData['MachineIdentifier']
    trainData.drop('MachineIdentifier', inplace = True, axis=1)
    trainData.drop('PuaMode', inplace = True, axis=1)
    trainData = DataFrameImputer().fit_transform(trainData)
    trainData = newImpute(trainData)
    #Converting the decimal columns to full numbers by removing the decimal points
    trainData.EngineVersion = trainData.EngineVersion.apply(lambda x: x.replace('.',''))
    trainData.AppVersion = trainData.AppVersion.apply(lambda x: x.replace('.',''))
    trainData.AvSigVersion = trainData.AvSigVersion.apply(lambda x: x.replace('.',''))
    trainData.OsVer = trainData.OsVer.apply(lambda x: x.replace('.',''))
    trainData.Census_OSVersion = trainData.Census_OSVersion.apply(lambda x: x.replace('.',''))
    print('Starting') 
    #print(trainData.isnull().sum() > 0)
    #enc = OneHotEncoder(handle_unknown='ignore')
    trainData = enc.transform(trainData)
    print('Starting with Scaler')
    trainData = scaler.transform(trainData)
    print('Finished with Scaler')
    trainData = pd.DataFrame(trainData.toarray())
    trainData = trainData.as_matrix()
    X = torch.tensor(trainData, dtype=torch.float64)
    X = Variable(X).float()
    model.eval()
    y_pred = model.forward(X)
    y_pred = y_pred.tolist()
    y_pred = list(chain(*y_pred))
    predictions = pd.DataFrame({'MachineIdentifier': machineIdent, 'HasDetections': y_pred})
    return predictions

for df in pd.read_csv('test.csv', chunksize=20000):
    predictions = makePredict(df)
    with open('submission.csv', 'a') as f:
        predictions.to_csv(f, header=False, index=False)
